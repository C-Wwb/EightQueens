#include <iostream>
using namespace std;
//0代表没有，1代表有
//全排列生成问题
int col[100] = {0};//当前格子所在列是否有皇后
int lef[100] = {0};//当前格子所在左斜线是否有皇后
int rig[100] = {0};//当前格子所在右斜线是否有皇后
int D[100] = {0};//D[i]表示在第i行第D[i]列放了皇后
int num = 0;//表示第num组皇后的解

void PQ1(int num)//根据PQ函数不停的递归和回溯后确定的D[i]放皇后的位置来打印
{
    cout<<endl<<endl;
    cout<<"Group"<<num<<"\n";//输出这是第几组解
    for(int i = 0;i <= 7;i++)
    {
        cout<<endl;
        for(int j = 0;j <= 7;j++)
        {
            if(j == D[i])//能放，在该位置打印‘1’，递归到下一行
            {
                cout<<"1  ";
            }
            else//不能放，则在该位置打印‘0’，回溯到上一行
            {
                cout<<"0  ";
            }
        }
    }
}

//庞大的工程来确定能放皇后的位置D[i]
void PQ(int i)
{
    for(int j = 0;j <= 7;j++)
    {
        if(!col[j]&&!lef[i+j]&&!rig[i-j+7])//判断放置的皇后于之前放置的皇后是否有冲突，若无冲突，执行if函数
        {
            D[i] = j;//把皇后放在当前列位置
            col[j] = lef[i+j] = rig[i-j+7] = 1;//1代表该列，左斜，右斜已被占有
            if(i < 7)//如果可以放，递归调用到下一行
            {
                PQ(i+1);//从j=0开始取，i从0开始，若满足上述条件，则i+1
            }
            else
            {
                PQ1(++num);//若成功定义了一组完整的D[i](即截至到i=7都没有问题了)，则把该D[i]的位置传给PQ1函数
                //来实现对于第一组八皇后的打印
            }
            col[j] = lef[i+j] = rig[i-j+7] = 0;//0代表该位置没有被占有
            //若j从0-7都无法使判断条件等于一，则更新占有状态并使i回溯
        }
    }
}
int main()
{
    PQ(0);
}

/*
 八皇后算法描述：
1.从第0行开始，从第0列开始判断该行是否有一列能放皇后，
  如果有，则放皇后递归调用到下一行，如果不能放则回溯回上一行
2.当放完8个皇后以后输出解，并回溯回上一行寻找下一组解
3.八皇后一个有92组解
4.将输出结果导出
 */